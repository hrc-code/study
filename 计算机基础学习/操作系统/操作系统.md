# 操作系统

- 定义

一种管理软件资源和硬件资源的系统软件

- 功能
  - 资源管理
    - 处理机管理
  - 存储器管理
    - 文件管理
    - 设备管理
  - 提供功能接口（命令接口---cmd、程序接口--系统调用）
  
- 特征
  - 并发
  - 共享
  - 虚拟
  - 异步

## 进程与线程

- 进程控制
  - 概念：将进程的状态进行转换
  - 进程状态
    - 创建态
    - 就绪态
    - 运行态
    - 阻塞态
    - 终止态
  -	实现原理：使用原语完成进程状态的转换
- 进程通信
  - 共享存储
    - 基于数据结构共享存储
    - 基于存储区共享存储
  - 管道通信
  - 消息传递
    - 直接传递
    - 间接传递
- 线程
  - 概念：轻量级进程
  - 特性
    - 同一进程的线程资源共享
    - 具有并发性
    - CPU调度的基本单位
  - 类型
    - 用户级线程
    - 内核级线程
  - 多线程模型
    - 一对一
      - 优点：并发能力强
      - 缺点：线程管理开销大
    - 多对一
      - 优点：线程管理开销小
      - 缺点：并发能力弱
    - 多对多
      - 并发能力一般，线程管理开销一般

#### 进程调度

![hrc_2023-07-12_15-23-32](操作系统/hrc_2023-07-12_15-23-32-1689148129049.png)

- 进程调度时机![hrc_2023-07-12_15-10-14](操作系统/hrc_2023-07-12_15-10-14.png)
     - 可以进程调度
        - 主动放弃
          - 进程正常终止
          - 运行过程中方式异常而终止
          - 阻塞（等待I/O)
        - 被动放弃
          - 分给进程的时间片用完
          - 有更紧急的事情需要处理(如 I/O 中断)
          - 有更高优先级的进程进入就绪队列
            - 不能进行进程调度
        - 在处理中断过程中
        - 进程在操作系统内核程序临界区中
        - 原子操作过程中(原语)
- 进程切换过程
  - 对原来运行进程各种数据的保存
  - 对新的进程各种数据的恢复
  - 进程调度、切换是有代价的，并不是调度越频繁，并发度就越高
- 进程调度方式
  - 非剥夺调度方式(非抢占式)
    - 只能由当前运行的进程主动放弃CPU
    - 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
  - 剥夺调度方式(抢占式)
    - 可由操作系统剥夺当前进程的CPU使用权
    - 可以优先处理更紧急的进程，也可以实现让各进程按照时间片轮流执行的功能(通过时钟中断)，适合分时操作系统、实时操作系统

##### 调度算法评估

- CPU利用率
- 系统吞吐量
- 周转时间
- 等待时间
- 响应时间

![hrc_2023-07-13_16-15-06](操作系统/hrc_2023-07-13_16-15-06.png)

-----------

#### 调度算法

> - 先来先服务算法(FCFS)
> - 短作业优先算法(SJF)
> - 高响应比优先(HRRN)
>
> ![hrc_2023-07-14_10-56-24](操作系统/hrc_2023-07-14_10-56-24.png)
>
> ![hrc_2023-07-14_11-07-04](操作系统/hrc_2023-07-14_11-07-04.png)
>
> ![hrc_2023-07-14_11-21-06](操作系统/hrc_2023-07-14_11-21-06.png)

-----

#### 硬件实现进程互斥的方法

> - 开/关中断指令
> - TestAndSet指令
> - Swap指令
>
> ![hrc_2023-07-15_17-05-04](操作系统/hrc_2023-07-15_17-05-04.png)

#### 信号量机制

---

> wait(S) 原语---P操作 和 signal(S) 原语---V操作，可以理解成我们自己写的函数

- 整形信号量

> 不能满足让权等待原则，存在while

```c
void wait(int S) {			void signal(int S) { 
    while (S<=0);				S = S + 1;
    S = S - 1;				}
}							
```

- 记录型信号量

> 满足让权等待原则，使用 if

```c
typedef struct {					void wait(semaphore S) {      void signal(semaphore S) {
    int value;剩余资源数量				S.value--;						S.value++;
    struct process *L;等待队列	           if (S.value<0) {				if (S.value>=0) {
} semaphore;						     block(S.L);					wakeup(S.L);
    								}							}
               					  }								}
```

![hrc_2023-07-16_21-26-21](操作系统/hrc_2023-07-16_21-26-21.png)

- 实现进程互斥

> 互斥问题信号量初始值设为1，临界资源只有一个。

- 实现进程同步

>  同步问题信号量初始值为0

- 实现进程的前驱关系

> 本质是多级同步问题，P操作可以看成一把🔒，V操作看成🔑，拿到🔑才可以解🔒

![image-20230717205433265](操作系统/image-20230717205433265.png)

- 消费者与生产者问题

> 这是一个进程同步与互斥的综合问题。

![hrc_2023-07-18_16-54-42](操作系统/hrc_2023-07-18_16-54-42.png)

细节

> **实现互斥的P操作一定要在实现P操作之后**，V操作不会导致进程堵塞，因此两个V操作顺序可以交换。

![hrc_2023-07-18_16-50-40](操作系统/hrc_2023-07-18_16-50-40.png)

#### 死锁

> 进程之间相互占有对方所需要的资源。

预防死锁

- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求和保持条件
- 破坏循环等待条件

![Snipaste_2023-07-20_14-10-56](操作系统/Snipaste_2023-07-20_14-10-56.png)