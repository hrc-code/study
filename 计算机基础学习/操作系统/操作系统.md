# 操作系统

#### 绪论

- 定义

一种管理软件资源和硬件资源的系统软件

- 功能
  - 资源管理
    - 处理机管理
  - 存储器管理
    - 文件管理
    - 设备管理
  - 提供功能接口（命令接口---cmd、程序接口--系统调用）
  
- 特征
  - 并发
  - 共享
  - 虚拟
  - 异步

#### 进程与线程

- 进程控制
  - 概念：将进程的状态进行转换
  - 进程状态
    - 创建态
    - 就绪态
    - 运行态
    - 阻塞态
    - 终止态
  -	实现原理：使用原语完成进程状态的转换

![Snipaste_2023-07-23_18-23-26](操作系统/Snipaste_2023-07-23_18-23-26.png)

- 进程通信
  - 共享存储
    
    > 简单理解就是，甲和乙中间有一个大布袋，甲和乙交换物品是通过大布袋进行的，甲把物品放在大布袋里，已拿走。但乙不能直接到甲的手中拿东西，甲也不能直接到乙的手中拿东西。还有任何人在向大布袋中放东西时，其他人不能向大布袋拿东西。
    
    - 基于数据结构共享存储
    - 基于存储区共享存储
    
  - 管道通信
  
    > 从管道读取数据是一次性操作，数据一旦被读取，它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用**半双工通信**，即某一时刻只能单向传输，要实现父子进程双方互动通信，需要定义两个管道。只有写进程将缓存区写满，读进程才能开始读取缓存区的数据，当缓存区中有数据的时候，写进程不会往缓存区写数据。
  
  - 消息传递
  
    > 简单理解就是，甲要告诉乙某件事，就要写信，然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上；间接通信就是乙家门口有一个邮箱，邮差把信放在邮箱中。
  
    - 直接传递
    - 间接传递
- 线程
  - 概念：轻量级进程
  - 特性
    - 同一进程的线程资源共享
    - 具有并发性
    - CPU调度的基本单位
  - 类型
    - 用户级线程
    - 内核级线程
  - 多线程模型
    - 一对一
      - 优点：并发能力强
      - 缺点：线程管理开销大
    - 多对一
      - 优点：线程管理开销小
      - 缺点：并发能力弱
    - 多对多
      - 并发能力一般，线程管理开销一般

进程调度

![hrc_2023-07-12_15-23-32](操作系统/hrc_2023-07-12_15-23-32-1689148129049.png)

- 进程调度时机![hrc_2023-07-12_15-10-14](操作系统/hrc_2023-07-12_15-10-14.png)
     - 可以进程调度
        - 主动放弃
          - 进程正常终止
          - 运行过程中方式异常而终止
          - 阻塞（等待I/O)
        - 被动放弃
          - 分给进程的时间片用完
          - 有更紧急的事情需要处理(如 I/O 中断)
          - 有更高优先级的进程进入就绪队列
            - 不能进行进程调度
        - 在处理中断过程中
        - 进程在操作系统内核程序临界区中
        - 原子操作过程中(原语)
- 进程切换过程
  - 对原来运行进程各种数据的保存
  - 对新的进程各种数据的恢复
  - 进程调度、切换是有代价的，并不是调度越频繁，并发度就越高
- 进程调度方式
  - 非剥夺调度方式(非抢占式)
    - 只能由当前运行的进程主动放弃CPU
    - 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
  - 剥夺调度方式(抢占式)
    - 可由操作系统剥夺当前进程的CPU使用权
    - 可以优先处理更紧急的进程，也可以实现让各进程按照时间片轮流执行的功能(通过时钟中断)，适合分时操作系统、实时操作系统

调度算法评估

- CPU利用率
- 系统吞吐量
- 周转时间
- 等待时间
- 响应时间

![hrc_2023-07-13_16-15-06](操作系统/hrc_2023-07-13_16-15-06.png)

调度算法

> - 先来先服务算法(FCFS)
> - 短作业优先算法(SJF)
> - 高响应比优先(HRRN)
>
> ![hrc_2023-07-14_10-56-24](操作系统/hrc_2023-07-14_10-56-24.png)
>
> ![hrc_2023-07-14_11-07-04](操作系统/hrc_2023-07-14_11-07-04.png)
>
> ![hrc_2023-07-14_11-21-06](操作系统/hrc_2023-07-14_11-21-06.png)

软硬件实现互斥的方法

> - 开/关中断指令
> - TestAndSet指令
> - Swap指令
>
> ![hrc_2023-07-15_17-05-04](操作系统/hrc_2023-07-15_17-05-04.png)

信号量机制

---

> wait(S) 原语---P操作 和 signal(S) 原语---V操作，可以理解成我们自己写的函数

- 整形信号量

> 不能满足让权等待原则，存在while

```c
void wait(int S) {			void signal(int S) { 
    while (S<=0);				S = S + 1;
    S = S - 1;				}
}							
```

- 记录型信号量

> 满足让权等待原则，使用 if

```c
typedef struct {					void wait(semaphore S) {      void signal(semaphore S) {
    int value;剩余资源数量				S.value--;						S.value++;
    struct process *L;等待队列	           if (S.value<0) {				if (S.value>=0) {
} semaphore;						     block(S.L);					wakeup(S.L);
    								}							}
               					  }								}
```

![hrc_2023-07-16_21-26-21](操作系统/hrc_2023-07-16_21-26-21.png)

- 实现进程互斥

> 互斥问题信号量初始值设为1，临界资源只有一个。

- 实现进程同步

>  同步问题信号量初始值为0

- 实现进程的前驱关系

> 本质是多级同步问题，P操作可以看成一把🔒，V操作看成🔑，拿到🔑才可以解🔒

![image-20230717205433265](操作系统/image-20230717205433265.png)

- 消费者与生产者问题

> 这是一个进程同步与互斥的综合问题。

![hrc_2023-07-18_16-54-42](操作系统/hrc_2023-07-18_16-54-42.png)

细节

> **实现互斥的P操作一定要在实现P操作之后**，V操作不会导致进程堵塞，因此两个V操作顺序可以交换。

![hrc_2023-07-18_16-50-40](操作系统/hrc_2023-07-18_16-50-40.png)

死锁

> 进程之间相互占有对方所需要的资源。

预防死锁

- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求和保持条件
- 破坏循环等待条件

![Snipaste_2023-07-20_14-10-56](操作系统/Snipaste_2023-07-20_14-10-56.png)

避免死锁

>  可以采用银行家算法避免死锁。

![Snipaste_2023-07-21_22-45-18](操作系统/Snipaste_2023-07-21_22-45-18.png)

死锁的检测和解除

> 死锁的检测就是利用资源分配图，判断是能够消除所有的边，不能消除的即存在死锁。

资源分配图

![Snipaste_2023-07-22_16-50-24](操作系统/Snipaste_2023-07-22_16-50-24.png)

总结

![Snipaste_2023-07-22_16-50-05](操作系统/Snipaste_2023-07-22_16-50-05-1690016314759.png)

#### 内存

> 程序运行前必须加载到内存中才能被CPU执行

单位

>  2 的 10 次方 = 1 k     2 的 20 次方 = 1 M   2 的 30 次方 = 1 G   
>
> 4 GB 内存的地址长度(按字节编址)为 2 的 32 次方 - 1

地址编码

- 按字节编码

  > 每个存储单元大小为一个字节

- 按字长编码

  > CPU字长为n字节，则每个存储单元大小为n字节

程序的生命周期

- 编辑源代码

- 编译源代码

  > 由编译器将源代码编译成目标模块(翻译成机器语言)

- 链接

  - 静态链接

    > 装入前链接成一个完整的装入模块(可执行文件)

  - 装入时动态链接

    > 运行时边装入边链接

  - 运行时链接

    > 运行时需要目标模块才装入并链接

- 装入

  - 绝对装入

    > 编译时产生物理地址

  - 可重定位装入(静态重定位)

    > 装入时将逻辑地址转换为物理地址

  - 动态运行时装入(动态重定位)

    > 运行时将逻辑地址转换为物理地址，需要设置重定位寄存器

总结

![Snipaste_2023-07-25_15-30-08](操作系统/Snipaste_2023-07-25_15-30-08.png)

内存管理

- 内存空间的分配与回收

  > 操作系统如何为进程分配内存空间

- 内存空间的扩展(实现虚拟化)

  > 如何运行大于内存条大小的进程

- 地址转换

  > 如何将逻辑地址转换为物理地址

  程序装入内存的三种方式

- 内存保护

  > 如何保障各进程在内存中互不随意访问对方内存空间

  - 设置上下限寄存器
  - 利用重定位寄存器、界地址寄存器进行判断

总结

![Snipaste_2023-07-26_21-46-15](操作系统/Snipaste_2023-07-26_21-46-15-1690379846752.png)

内存空间的扩充

- 覆盖技术(已过时)

- 交换技术

  > 将进程挂起，放入外存中的对换区

总结

![Snipaste_2023-07-27_15-52-24](操作系统/Snipaste_2023-07-27_15-52-24.png)

连续分配管理

> 内部碎片 ： 分配给进程的内存空间中，进程未使用的部分  
>
> 外部碎片： 未分配的内存空间，但由于内存空间太小，所有的进程都无法使用的部分

- 单一连续分配

  - 只支持单道程序
  - 无外部碎片，有内部碎片

- 固定分区分配

  - 支持多道程序
  - 无外部碎片，有内部碎片

- 动态分区分配

  > 程序加载到内存时动态的为进程分配内存空间

  - 支持多道程序
  - 无内部碎片，有外部碎片

总结

![Snipaste_2023-07-28_22-03-23](操作系统/Snipaste_2023-07-28_22-03-23.png)

动态分区分配算法

- 首次适应算法

  - 思想

    > 空闲分区按照低地址递增排序，每次从最低地址开始寻找满足进程的内存空间

- 最佳适应算法

  - 思想

    > 空闲分区按照分区大小递增排序，每次从最小分区开始寻找满足进程的内存空间

- 最坏适应算法

  - 思想

    > 空闲分区按照分区大小递减排序，每次从最大分区开始寻找满足进程的内存空间

- 邻近适应算法

  - 思想

    > 空闲分区按照低地址递增排序，每次从上次分配的空间开始寻找满足进程的内存空间

总结

![Snipaste_2023-07-29_19-46-37](操作系统/Snipaste_2023-07-29_19-46-37.png)

基本分页存储管理

- 页面

  > 进程被均匀分成多个页面  

- 页表

  > 相当于一维数组  ，由页号与内存块号组成，页号相当于数组下标，内存块号相当于存储元素。页表存放再PCB中

- 逻辑地址

  > 对物理地址的抽象，便于编程人员使用物理地址

  ![Snipaste_2023-07-30_22-42-41](操作系统/Snipaste_2023-07-30_22-42-41.png)

- 地址转换

  > 物理地址 = 页面始址 + 页内偏移量
  >
  > 页号 = 逻辑地址/页面长度  
  >
  > 页内偏移量 = 逻辑地址 % 页面长度

  ![Snipaste_2023-07-30_22-43-51](操作系统/Snipaste_2023-07-30_22-43-51.png)

  ![Snipaste_2023-07-30_22-44-13](操作系统/Snipaste_2023-07-30_22-44-13.png)

总结

![Snipaste_2023-07-30_22-35-37](操作系统/Snipaste_2023-07-30_22-35-37.png)