# 多线程

多线程的实现方法

- 继承Thread,并且重写run()
- 实现Runnable接口,并且重写run()
- 实现Callable接口，并且重写call()

 Thread中常用的API

static Thread currentThread()

> 返回正在执行的线程对象

解决线程安全问题

- 同步代码块
- 同步方法(synchronized)
- 使用锁(ReentrantLock)
- volatile

线程池

> 当核心线程用完时，提交任务加入阻塞队列
>
> 当核心线程用完时，且阻塞队列已满时，创建临时线程
>
> 当核心线程用完，阻塞队列已满，临时线程用完时，触发拒绝策略
>
> 只有当核心线程被全部使用完且阻塞队列已满时，才会生产临时线程。
>
> 任务提交顺序不一定是执行顺序。

七个参数

- 核心线程数

  > 永远存活的线程，除非线程池关闭

- 最大线程数

  > 临时线程数 = 最大线程数 - 核心线程数

- 临时线程存活时间

- 存活时间的单位

- 阻塞队列

  > 当核心线程被全部使用时，将提交的任务放入该队列

- 线程工厂(使用Executors工具类创建)

- 拒绝策略(线程池中的静态内部类)

  - 直接抛弃且抛出异常
  - 直接抛弃且不抛出异常
  - 抛弃阻塞队列中任务时间最长的，且将该任务加入阻塞队列
  - 直接由主线程执行提交任务，不由线程池执行

  > 当全部的线程用完且阻塞队列已满时，对提交的任务处理策略

工具类

- ConcurrentHashMap

  - 1.7原理(分段锁)
    - 数据结构 数组 + 单向链表
  - 1.8原理(节点锁)
    - 数据结构 数组 + 单向链表 + 红黑树

- Hashtable

- CountDownLatch

  > 让一个线程等待其他线程执行完毕之后再执行自己的任务

- Semaphore

  >  可以控制访问特定资源的线程数量